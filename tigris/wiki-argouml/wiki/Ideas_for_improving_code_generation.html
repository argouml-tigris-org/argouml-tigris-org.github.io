---
layout: oldtigrissite
---
<h1><small>From the ArgoUML wiki at argouml.tigris.org.</small><br />         Wiki: Ideas for improving code generation
    </h1>
</div>
 
 
 
        
                 
                 
           
    
  

 
 





<div class="wiki">




<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867">
<h2 id="head-d6ad49397e798c624bbf9cdd54db2701fbfe9290">Introduction</h2>
<span class="anchor" id="line-2"></span><p class="line874">The purpose of this page is to collect the ideas for improving ArgoUML's code generation capabilities.  A number of discussions  <span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><p class="line874">The current approach to code generation has a number of shortcomings: <span class="anchor" id="line-5"></span><span class="anchor" id="line-6"></span><ul><li>The templates are not accessible by users, and therefore not customizable by them.  Generated code must often be "processed" to include company file headers. <span class="anchor" id="line-7"></span><span class="anchor" id="line-8"></span></li><li class="gap">The templating language is specific to the ArgoUML project and is not likely to be familiar to developers experienced with Velocity and Freemarker. <span class="anchor" id="line-9"></span><span class="anchor" id="line-10"></span></li><li class="gap">By exposing the templates, it makes it possible for ArgoUML to more easily support code generation for additional languages.   <span class="anchor" id="line-11"></span><span class="anchor" id="line-12"></span></li></ul><p class="line867">
<h2 id="head-0119ecbe43359a2e19beabe29aa4355975893b2f">Ideas</h2>
<span class="anchor" id="line-13"></span><span class="anchor" id="line-14"></span><p class="line862">The <a class="http" href="http://argoprint.tigris.org/">ArgoPrint</a> project provides support for pluggable templating engines, and currently supports Velocity and XSLT.  A similar approach to code generation would make the process of creating templates more approachable by the average developer with a few hours to spare. <span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span><p class="line867"><a class="http" href="http://argoprint.tigris.org/">ArgoPrint</a> uses a class called <a class="http" href="http://argoprint.tigris.org/source/browse/argoprint/trunk/src/org/argoprint/util/DiagramUtil.java?revision=327&amp;view=markup">DiagramUtils</a> that makes it easier to access elements of the diagram from within the template. A similar set of utility methods would be needed to support code generation templates. <span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span><p class="line862">Another option to consider is to generate code using the MDA standard, possibly with some Action Language for <a class="http" href="http://en.wikipedia.org/wiki/Executable_UML">xUML/xtUML</a>. ArgoUML works together with <a class="http" href="http://andromda.org/">AndroMDA</a> to solve the MDA-part. We could go further in this. The funny thing here is, that they use Velocity as their default template engine, e.g. see the <a class="http" href="http://galaxy.andromda.org/index.php?option=com_content&amp;task=blogcategory&amp;id=35&amp;Itemid=77&amp;limit=1&amp;limitstart=7">sample templates</a> in their tutorial, so modeling for AndroMDA is a high sophisticated way to use a Velocity driven generator approach. <span class="anchor" id="line-19"></span><span class="anchor" id="line-20"></span><p class="line874">Another option is to use a UML model as the template language for code generators. A UML model could contain all information needed to determine a generator, e.g. code fragments (with placeholders) in tagged values. In comparison to Velocity we'd have the following: instead of reading a VTL file and let Velocity create a generator from it, we read some XMI file into some piece of software that creates a generator from it. The disadvantage: we need to develop that piece of software and define a keen UML code generator template profile. The advantage: we can use ArgoUML to model code generators. <span class="anchor" id="line-21"></span><span class="anchor" id="line-22"></span><p class="line867">
<h2 id="head-3bb4e61ff573d6725f9154360d3d25316cb6854e">what's going in</h2>
<span class="anchor" id="line-23"></span><span class="anchor" id="line-24"></span><ol type="1"><li>user selection <span class="anchor" id="line-25"></span><ul><li style="list-style-type:none">The user selects elements to generate, for example: classes or packages. If baseclasses are not selected this will result in not compilable code. This is currently implemented and the selected elements are passed to the generator's interface. it's up to the generator to find the contained elements(like methods for a class) to generate. <span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span></li></ul></li><li class="gap">whole project <span class="anchor" id="line-28"></span><ul><li style="list-style-type:none">Activates the generator and the generator decides what to generate by choosing all elements it can handle of the current project to generate code. This is currently available but it works like the user selection by passing a list of elements to the generator. <span class="anchor" id="line-29"></span><span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span></li></ul></li></ol><p class="line867">
<h2 id="head-642936d02f3591cb895db38806fac28ed660ddf6">how it's going in</h2>
<span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><ol type="1"><li>argouml calls the generator with the elements to generate. this is currently implemented. <span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span></li><li class="gap">argouml provides access to the model of the current project and the generator traverses through it. this is currently implemented, but intented only to find the necessary elements for generating the selected elements. <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span></li><li class="gap">argouml provides access to(or feeds into the generator) the xmi of the whole project. this would open the way for xslt-based code generators. <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span></li></ol><p class="line867">
<h2 id="head-34785c626dc979a383dbfaf65995c7d07589cc5f">options</h2>
<span class="anchor" id="line-40"></span><p class="line874">the generator should provide options to the user to tune the result of the code generation. from the generator side there must not be gui-elements for doing this. there is a mechanism for the generator-side to use descriptions of options, although it's not heavily used yet. <span class="anchor" id="line-41"></span><span class="anchor" id="line-42"></span><p class="line867">
<h2 id="head-a4a241e8bc237246f5eafc9a240628c24b04cd05">profiles</h2>
<span class="anchor" id="line-43"></span><p class="line874">profiles are a great thing to handle specific patterns. for example, classes to be used with your favourite or-mapper can be stereotyped as this, using a specific profile for that orm. the code generator should be able to recognize these stereotypes.  <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><p class="line874">normally the profile and the code generator are independent things, but if the generator should handle stuff from the profile, it has to know it of course. <span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><p class="line867">
<h2 id="head-580088b0615d320bb5ade2307ada0e05d1d73481">Use Cases</h2>
<span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><p class="line867">
<h3 id="head-86a29404090134dfd42149e0ed08331c9cb9d7b9">Class/Class List Generation</h3>
<span class="anchor" id="line-50"></span><p class="line874">The user should be able to select a subset of classes to be generated.   <span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><p class="line867">
<h3 id="head-d0dbc270c149cdbcca95975ae8ff01f3c24fb11c">Project Code Generation</h3>
<span class="anchor" id="line-53"></span><p class="line874">The user should be able to generate code for an entire project as specified in the UML model.  There are two types of code generation scenarios: straight code generation, RAD environment code generation. <span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span><p class="line867">
<h4 id="head-006348c1df8276bcb7a50f3c5b5eebeef248d5a1">Straight Code Generation</h4>
<span class="anchor" id="line-56"></span><p class="line862">In this scenario a user selects an output directory, and a template and the generator iterates through all of the class diagrams, and generates classes for each diagram &amp; package found. <span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><p class="line867">
<h4 id="head-bb26ec3d171b53d4ea0f6c8cfb3914d59c1a68ec">RAD Environment Code Generation</h4>
<span class="anchor" id="line-59"></span><p class="line874">Tools like Rails and Grails use convention, to determine where particular types of classes reside.  For example, Grails uses a "$app_root/grails-app/controllers" directory to contain all controllers used in the application, a "$app_root/grails-app/domain" for domain objects, etc.   <span class="anchor" id="line-60"></span><span class="anchor" id="line-61"></span><p class="line874">When generating files for a RAD environment, the tool must know the conventions used by the RAD environment and place the generated code in the appropriate directory. <span class="anchor" id="line-62"></span><span class="anchor" id="line-63"></span><p class="line874">To create a model suitable for use in a Grails project, the user would: <span class="anchor" id="line-64"></span><ol type="1"><li>Select the Grails profile which would contain stereotypes such as "Controller", "Service", "Domain", and "Page". <span class="anchor" id="line-65"></span></li><li>The user would create a class diagram (or set of diagrams) to model the domains, controllers and services to be used in the project. <span class="anchor" id="line-66"></span></li><li>The user could create a deployment diagram containing the webflow for the project. <span class="anchor" id="line-67"></span></li><li><p class="line862">The user would select "Generate Project", and the ProjectGenerator would identify the profile being used, and generate the classes in the appropriate directories.  The profile would contain tagged values indicating the appropriate directories for classes of a given stereotype.  The profile would also indicate which template should be used for classes of a given stereotype. <span class="anchor" id="line-68"></span><span class="anchor" id="line-69"></span></li></ol><p class="line867">
<h3 id="head-8993bf817bc98e55886132ea000458eb5074e4c4">Code Generation for Non-Class Diagrams</h3>
<span class="anchor" id="line-70"></span><p class="line874">There are other diagrams for which a user might want to generate code.   <span class="anchor" id="line-71"></span><span class="anchor" id="line-72"></span><p class="line867">
<h4 id="head-9e3bb67c21ba2d7f64dd1fab5a3731ac65413286">State Diagrams</h4>
<span class="anchor" id="line-73"></span><p class="line862">For example, generating a state machine from a state diagram would be very useful for projects which need to expose state machine rules to users.  <a class="http" href="http://commons.apache.org/scxml/">Apache's SCXML</a> project is an example of one such state machine.  A user could generate an SCXML file, including JavaScript code directly from a model. <span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><p class="line867">
<h4 id="head-f3a77f993bb9a857d3000c05c83c53749c9d1ab8">Deployment Diagrams</h4>
<span class="anchor" id="line-76"></span><p class="line862">It would be useful to be able to generate deployment descriptors for EJB projects from a deployment diagram.  It might also be useful to convert a deployment diagram into an application monitoring page in SVG.  The user would then be able to monitor the state of the application using a combination of SVG/JavaScript/REST and JMX. <span class="anchor" id="line-77"></span><span class="anchor" id="line-78"></span><p class="line867">
<h1 id="head-8e71d3fa29fd4c66fb82acde3d8934d890062ae8">Design</h1>
<span class="anchor" id="line-79"></span><p class="line867"><a href="Templated_Code_Generation_Design.html">Templated Code Generation Design</a> <span class="anchor" id="line-80"></span><span class="anchor" id="bottom"></span></div><p id="pageinfo" class="info" lang="en" dir="ltr">Ideas for improving code generation  (last edited 2011-09-05 19:30:57 -0700 by <span title="Mark Fortner @ localhost[127.0.0.1]">phidias</span>)</p>

