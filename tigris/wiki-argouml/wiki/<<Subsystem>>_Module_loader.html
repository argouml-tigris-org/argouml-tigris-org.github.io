---
layout: oldtigrissite
---
<h1><small>From the ArgoUML wiki at argouml.tigris.org.</small><br />         Wiki: &lt;&lt;Subsystem&gt;&gt; Module loader
    </h1>
</div>
 
 
 
        
                 
                 
           
    
  

 
 





<div class="wiki">




<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><dl><dt>Purpose</dt><dd>to provide the mechanisms to load (and unload) the auxiliary modules. <span class="anchor" id="line-2"></span></dd><dt>Located</dt><dd><p class="line891"><strong>org.argouml.moduleloader</strong> <span class="anchor" id="line-3"></span></dd><dt>Layer</dt><dd>? <span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span></dd></dl><p class="line867">
<h2 id="head-6ab305ffa9a818ba27590e4a6e595fd3b0416e33">Description</h2>
<span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line874">It is the modules' responsibility to connect and register to the subsystem or subsystems it is going to work with using that subsystem's API, Facade, or Plug-in interface. <span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line862">A previous implemention of the module loader was located in org.argouml.application.modules.ModuleLoader with interfaces (Pluggable) in org.argouml.application.api, but it has been replaced by the interface described here. <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line862">For details on how to build a module see Modules. <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line867">
<h3 id="head-997c3547aa4381f0991eb5767cb85a2f0917067c">What the ModuleLoader does</h3>
<span class="anchor" id="line-14"></span><p class="line862">The ModuleLoader looks for module jars. It scans through all jars available in the ext directory. See Edit Settings Environment tab. If you turn on logging on the debug level while running ArgoUML you should be able to see what jar files it finds and what it does with them. <span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span><p class="line874">A module jar contains the classes, resources and a manifest file. The manifest file points out the class to be loaded. Also notice that the Specification-Title and Vendor must be specified correctly for this to work. [What does "correctly" mean in this context?] <span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span><p class="line867">
<h3 id="head-1fe7cd1de6a321a699ed96b23c205fe7d1f153ad">Design of the Module Loader</h3>
<span class="anchor" id="line-19"></span><p class="line874">Design: <span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><p class="line874">We use a Loadable Proxy Pattern(?) for the modules. <span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><p class="line874">Each module can be enabled and disabled individually. Dependencies between modules are allowed although not yet handled gracefully. <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><p class="line862">Each module is required to have one (1) class that implements ModuleInterface. That class (and all other classes that constitute the module) needs to be made available for some class loader, either by including it in the classpath or by letting the module loader hunt for it. <span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><p class="line874">The modules are allowed to use all the APIs available from all the subsystems within ArgoUML and from other modules. <span class="anchor" id="line-28"></span><span class="anchor" id="line-29"></span><p class="line874">This is a big improvement over the old module loader in that: <span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span><p class="line874">We use the same APIs for the modules that we use within ArgoUML meaning that we implement and document it only once. This replaces the Pluggable class at every point where ArgoUML can be augmented. <span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><p class="line874">We can have the module have different classes to register at different parts of ArgoUML. <span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><p class="line874">We can have dynamic registrations that the module add and remove over time depending on some criteria that the module decides. <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line874">We don't need to search through all modules at every possible point where ArgoUML can be augmented. <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><p class="line874">Just as in the old solution, whenever a module needs to do something to ArgoUML, there needs to be implemented an API, possibly with registration/deregistration and callbacks. <span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line874">All modules that can be found are examined at startup. They can be enabled and disabled individually from a special available modules window but have a default state that applies if the user hasn't taken action. Currently the default state is "enabled". <span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><p class="line874">Dependency between modules! <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><p class="line874">If a module cannot be enabled because some other module needs to be enabled first or because some part of ArgoUML needs to be initialized first this is a problem. This is because the initial implementation is such that we have no register of dependencies. <span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><p class="line874">The solution suggested is that the module loader persists in its attempts to enable a module so that the order among the modules is not important. For this to work the modules needs to signal when they fail. This is done by returning false or throwing an Exception from the module enabling method. <span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><p class="line874">The module loader also provides an API that the well-behaving modules can use to test if the modules they depend on are enabled. The less well-behaving modules can just throw an exception when they fail to enable themselves properly. <span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span><p class="line874">If a module cannot be disabled, because some other module depends on it then this is signaled by returning false from the disabling method. <span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><p class="line874">Where modules are loaded from? <span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span><p class="line862">The modules are loaded from the same places as in the old module loader. They can be internally i.e. available in the core jar file of ArgoUML, from the ext directory, or if running from JavaWebStart, they can be downloaded from the site. <span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><p class="line862">To reduce the complexity of the downloads, let's use it in the simplest possible way: organize each module in a package and a jar file, have the jnlp-file list that jar file as a part and a package entry listing the classes, have a file listing optional classes and a GUI that allows the user to download them. Once a class is selected in the GUI it is loaded and, the JavaWebStart class loader will guarantee that it is available. <span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><p class="line874">The scope of the modules. <span class="anchor" id="line-60"></span><span class="anchor" id="line-61"></span><p class="line874">Modules are always enabled and disabled on a per-application (per jvm) basis and not on a per-project or per-frame basis. <span class="anchor" id="line-62"></span><hr /><p class="line874"> <span class="anchor" id="line-63"></span><a href="CategoryFromCookbook.html">CategoryFromCookbook</a> <span class="anchor" id="line-64"></span><span class="anchor" id="bottom"></span></div><p id="pageinfo" class="info" lang="en" dir="ltr">&lt;&lt;Subsystem&gt;&gt; Module loader  (last edited 2009-02-08 10:05:42 -0700 by <span title="Linus Tolke @ localhost[127.0.0.1]"><a href="linus.html" title="Linus Tolke @ localhost[127.0.0.1]">linus</a></span>)</p>

