<h1><small>From the ArgoUML wiki at argouml.tigris.org.</small><br />         Wiki: &lt;&lt;Subsystem&gt;&gt; Model
    </h1>
</div>
 
 
 
        
                 
                 
           
    
  

 
 





<div class="wiki">




<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><dl><dt>Purpose</dt><dd>To remove knowledge from the rest of ArgoUML of what model repository is in use (e.g. MDR, EMF/UML2, NSUML) and to give a consistent interface for manipulating data within those repositories. <span class="anchor" id="line-2"></span></dd><dt>Located</dt><dd><p class="line891"><strong>org.argouml.model</strong> <span class="anchor" id="line-3"></span></dd><dt>Layer</dt><dd><p class="line891"><a href="&lt;&lt;Layer&gt;&gt;_Low-level_subsystems.html">&lt;&lt;Layer&gt;&gt;_Low-level_subsystems</a> <span class="anchor" id="line-4"></span></dd><dt>Facade classes</dt><dd><p class="line891"><strong>org.argouml.model.Model</strong>, <strong>org.argouml.model.*Factory</strong>, <strong>org.argouml.model.*Helper</strong> <span class="anchor" id="line-5"></span></dd><dt>See also</dt><dd><p class="line891"><a href="Model_Interface_History.html">Model Interface History</a> and <a href="Model_Interface_Criticisms.html">Model Interface Criticisms</a>. <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span></dd></dl><p class="line867">
<h3 id="head-94cf3558ed5e6fc193df286795cf0d457cc199ac">Public API</h3>
<span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line874">The Model class provides the rest of ArgoUML with various interfaces through which ArgoUML can manipulate the repository. <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line874">The Model subsystem manages the well-formedness rules for the data in the repository for those well-formedness rules that are considered important to enforce. <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line874">Currenty there are factory and helper interfaces for controlling the lifetime and properties of elements in the repository. <span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><p class="line874">An interface is also made available to the Diagram Interchange Model should the repository implementation contain such. <span class="anchor" id="line-16"></span><span class="anchor" id="line-17"></span><p class="line862">A <tt>ModelEventPump</tt> interface is provided through which ArgoUML can listen for changes in the repository in a consistent way. Implementations of this pump convert from the repository specific events to <tt>PropertyChangeEvent</tt>s. <span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span><p class="line874">The factories contain all methods that deal with creating and building model elements. The helpers contain all utility methods needed to manipulate the model elements. Per section of the semantics chapter of the UML specification there is one factory and one helper. <span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><p class="line867">
<h3 id="head-e29c6b0fe1d09619f8ddccfe80281e46559b5fed">Design of the subsystem</h3>
<span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><p class="line874">The Model is a Model subsystem according the MVC pattern (Model-View-Control). <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><p class="line862">Currently there is a full implementation using Net<strong></strong>Beans MDR to store the OMG UML 1.4 metamodel. The previous implementation used the NSUML library to implement a UML 1.3 metamodel. Since the 0.29.x releases, there is also an implementation using eclipse UML2 and EMF for the OMG 2.x metamodel. It begun in 2007 as a GSoC work an is called <a href="eUML.html">eUML</a> since then. This implementation is incomplete, but will eventually evolve into the first ArgoUML release with stable <a href="UML_2.x_support.html">UML 2.x support</a>. <span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><p class="line862">The decision of which implementation to use is controlled by the <tt>Model</tt> class which contols the implementations as alternative strategies (as in the Strategy Pattern - GOF p315) <span class="anchor" id="line-28"></span><span class="anchor" id="line-29"></span><p class="line862">Both helpers and factories (and the <tt>Facade</tt> and <tt>ModelEventPump</tt>) are interfaces that are fetched through static methods in the <tt>Model</tt> object. <span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span><p class="line874">Because the same interface is used internally each implementation must provide objects for each of these interfaces. <span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><p class="line867">
<h3 id="head-1f952c1aed71242ee8b4a7308a0fa51323bd145d">Factories</h3>
<span class="anchor" id="line-34"></span><p class="line867">
<h4 id="head-a386688401bb877510b4da1895647f27a4fe1b81">Create and Build</h4>
<span class="anchor" id="line-35"></span><span class="anchor" id="line-36"></span><p class="line862">The factories contain in most cases a create method for each model element. Example: createClass resides in <tt>CoreFactory</tt>-interface. <span class="anchor" id="line-37"></span><span class="anchor" id="line-38"></span><p class="line874">Besides that, there are several build methods to build classes. The build methods have a signature like public Object buildMODELELEMENTNAME(params);. <span class="anchor" id="line-39"></span><span class="anchor" id="line-40"></span><p class="line874">Each build method is intended to follow the wellformedness rules as defined in the UML spec. The reason for having extra build methods, is that the model repository does not enforce the wellformedness rules even though, in some cases, non-well-formed UML can lead to non-well-formed XMI which leads to saving/loading issues and all kinds of illegal states of ArgoUML. <span class="anchor" id="line-41"></span><span class="anchor" id="line-42"></span><p class="line874">If you want to create an element you shall use the build or create methods in the factories. You are strongly advised to use a build method or, if there is none that suits your needs, to write a new one reusing the already existing build methods and utility methods in the helpers. The reason for this is that the event listeners for the newly created model element are setup correctly. <span class="anchor" id="line-43"></span><span class="anchor" id="line-44"></span><p class="line867">
<h4 id="head-1e802a0417fef340078509e08694f22b0630496c">Copy and DoCopy</h4>
<span class="anchor" id="line-45"></span><span class="anchor" id="line-46"></span><p class="line862">The factories also contain methods that deal with copying modelelements. They are not supposed to be called directly from outside the model-subsystem, but only from the <tt>CopyHelper</tt>-implementation. The <tt>CopyHelper</tt> has one method that copies any modelelement into a new "location" (mostly a namespace). This method determines the type of element to copy, and then dispatches the call to the appropriate method of a Factory that is named in a similar way to <tt>copyClass</tt>. <span class="anchor" id="line-47"></span><span class="anchor" id="line-48"></span><p class="line862">The responsibility of the <tt>copyModelElement</tt> method is to create the new element (with <tt>createModelElement</tt>) and set the containment. Then, if necessary, sub-elements are to be created. E.g. the <tt>CoreFactoryMDRImpl</tt>. copyEnumeration method also creates <tt>EnumerationLiteral</tt>s, with the <tt>createEnumerationLiteral</tt> method. <span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><p class="line874">Then a next method is called to copy all the attributes from the old element to the newly created one: doCopyModelElement. This type of method shall only set attributes and lay associations, but not create any more elements. <span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><p class="line862">The implementation of these copy related methods is far from complete. Only the <tt>CoreFactory</tt> already has the most important functions. <span class="anchor" id="line-53"></span><span class="anchor" id="line-54"></span><p class="line867">
<h4 id="head-cc2a9405f1293b431eaf049768c2750fd7ffdc3d">Multi-threading</h4>
<span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><p class="line874">Question: Am I allowed to call the factories from any thread? Answer: The current checks are not written to allow for multiple threads so don't! <span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><p class="line867">
<h3 id="head-ced541114b45300072f4c820a2bd7ac2039068db">Helpers</h3>
<span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><p class="line862">The helpers contain all utility methods for manipulating model elements. For example, they contain methods to get all model elements of a certain class out of the model (see <tt>getAllModelelementsOfKind</tt> in <tt>ModelManagementHelper</tt>). <span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><p class="line862">To find a utility method you need to know where it is. As a rule of thumb, a utility method for some model element is defined in the helper that corresponds with the section in the UML specification. For example, all utility methods for manipulating classes are defined in <tt>CoreHelper</tt>. <span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><p class="line874">There are a few exceptions to this rule, mainly if the utility method deals with two model elements that correspond to different sections in the UML specification. Then you have to look in both corresponding helpers and you will probably find what you are searching for. <span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><p class="line874">Question: Am I allowed to call the helpers from any thread? Answer: The current checks are not written to allow for multiple threads so don't! <span class="anchor" id="line-67"></span><span class="anchor" id="line-68"></span><p class="line867">
<h3 id="head-52c70d90d26acdf4e3e8d52cf4c25b2461cb79ec">The model event pump</h3>
<span class="anchor" id="line-69"></span><p class="line867">
<h4 id="head-0855a8d7242b35f4760138787176bf9d35911b20">Introduction</h4>
<span class="anchor" id="line-70"></span><span class="anchor" id="line-71"></span><p class="line874">In late 2002, the existing NSUML model implementation was encapsulated with a new interface to separate it from the main ArgoUML application. This interface consists of three parts: <span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span><ol type="1"><li>The model factories, responsible for creation and deletion of model elements <span class="anchor" id="line-74"></span></li><li>The model helpers, responsible for utility functions to manipulate the model elements and <span class="anchor" id="line-75"></span></li><li>The model event pump, responsible for sending model events to the rest of ArgoUML. <span class="anchor" id="line-76"></span><span class="anchor" id="line-77"></span></li></ol><p class="line874">The model factories and the model helpers are described in Section “Factories” and Section “Helpers” respectively. <span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span><p class="line862">In the beginning of 2003, in the work to replace NSUML, the need was seen for this interface to not use any NSUML classes. The <tt>ModelFacade</tt> was introduced to wrap model factories, model helpers, and direct calls to NSUML but not the model event pump. In April 2004 a <tt>ModelEventPump</tt>-interface was introduced to wrap the <tt>UmlModelEventPump</tt> using <tt>PropertyChangeEvent</tt>s. <span class="anchor" id="line-80"></span><span class="anchor" id="line-81"></span><p class="line874">The model event pump is the gateway between the model elements and the rest of ArgoUML. Events fired by the model elements are caught by the pump and then 'pumped' to those listeners interested in them. The main advantage of this strategy is that the registration of listeners is concentrated in one place (see picture *). This makes it easier to change the interface between the model and the rest of ArgoUML. <span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><p class="line874">Besides this, there are some improvements to the performance of the pump made in comparison to the situation without the pump. The main improvement is that you can register for just one type of event and not for all events fired by some model element. In this respect the pump works as a filter. <span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><p class="line874">The model event pump replaces all other event mechanisms for model events. <span class="anchor" id="line-86"></span><span class="anchor" id="line-87"></span><p class="line867"><img src="eventsbeforepump.gif" /> <span class="anchor" id="line-88"></span><img src="eventsafterpump.gif" /> <span class="anchor" id="line-89"></span><span class="anchor" id="line-90"></span><p class="line867">
<h4 id="head-94cf3558ed5e6fc193df286795cf0d457cc199ac-2">Public API</h4>
<span class="anchor" id="line-91"></span><span class="anchor" id="line-92"></span><p class="line874">A model event (from now on a Event) has a name that uniquely identifies the type of the event. In most cases the name of the Event is equal to the name of the property that was changed in the model. In fact, there is even a 1-1 relationship between the type of Event and the property changed in the model. Therefore most listeners that need Events are only interested in one type of Event since they are only interested in the status of one property. <span class="anchor" id="line-93"></span><span class="anchor" id="line-94"></span><p class="line874">You can not make any assumptions about the thread on which the event will be delivered. In the MDR implementation, events are delivered on the MDR event dispatching thread which is guaranteed to be different than the Swing/AWT event dispatching thread, so you must not call any non-thread-safe Swing methods (ie most of them). TODO: is there something I cannot do from the event thread? <span class="anchor" id="line-95"></span><span class="anchor" id="line-96"></span><p class="line874">In the case described above (the most common one) you only have to subscribe with the pump for that type of event. This is explained in section Section “ How do I register a listener for a certain type event ” and Section “How do I remove a listener for a certain event” <span class="anchor" id="line-97"></span><span class="anchor" id="line-98"></span><p class="line874">Besides the case that you are interested in only one type of event (or a set of types), there are occasions that you are interested in all events fired by a certain model element or even for all events fired by a certain type of model element. For these cases, the pump has functionality too. This is described in section Section “ Hey, I saw some other methods for adding and removing? ”. <span class="anchor" id="line-99"></span><span class="anchor" id="line-100"></span><p class="line867">
<h5 id="head-124f3aa64a78d12695d70da0166ff68ee930b99a">How do I register a listener for a certain type event</h5>
<span class="anchor" id="line-101"></span><span class="anchor" id="line-102"></span><p class="line874">This is really very simple. Use the model <span class="anchor" id="line-103"></span><span class="anchor" id="line-104"></span><p class="line867"><span class="anchor" id="line-105"></span><pre>addModelEventListener(PropertyChangeListener listener, Object modelelement,
<span class="anchor" id="line-106"></span>    String eventName)
<span class="anchor" id="line-107"></span></pre><span class="anchor" id="line-108"></span><span class="anchor" id="line-109"></span><p class="line874">like this: <span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><p class="line867"><span class="anchor" id="line-112"></span><pre>Model.getPump().addModelEventListener(this, modelelementIAmInterestedIn,
<span class="anchor" id="line-113"></span>    "IamInterestedInThisEventnameType");
<span class="anchor" id="line-114"></span></pre><span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><p class="line862">Now your object this gets only the Events fired by <tt>modelElementIAmInterestedIn</tt> that have the name <tt>IamInterestedInThisEventnameType</tt>. <span class="anchor" id="line-117"></span><span class="anchor" id="line-118"></span><p class="line867">
<h5 id="head-a7aa135f964ad959b32938dacc6fd7a48c5da799">How do I remove a listener for a certain event</h5>
<span class="anchor" id="line-119"></span><span class="anchor" id="line-120"></span><p class="line874">This is the opposite of registering a listener. It all works with the method <span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><p class="line867"><span class="anchor" id="line-123"></span><pre>removeModelEventListener(PropertyChangeListener listener, Object modelElement, String eventName)
<span class="anchor" id="line-124"></span></pre><span class="anchor" id="line-125"></span><span class="anchor" id="line-126"></span><p class="line862">on the <tt>ModelEventPump</tt> like this: <span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span><p class="line867"><span class="anchor" id="line-129"></span><pre>Model.getPump().removeModelEventListener(this, modelelementIAmInterestedIn, "IamInterestedInThisEventnameType");
<span class="anchor" id="line-130"></span></pre><span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span><p class="line874">Now your object is not registered any more for this event type. <span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><p class="line867">
<h5 id="head-12dada1c19609231edf2cc94c073e5d97505ff0d">Hey, I saw some other methods for adding and removing?</h5>
<span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><p class="line874">Yes there are some other method for adding and removing. You can add a listener that is interested in ALL events fired by a certain model elements. This works with the method: <span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><p class="line867"><span class="anchor" id="line-139"></span><pre>addModelEventListener(PropertyChangeListener listener, Object modelelement)
<span class="anchor" id="line-140"></span></pre><span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span><p class="line874">As you can see, there are no names of events. <span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><p class="line874">Furthermore, you can add a listener that is interested in several types of events but coming from 1 model element. This is a convenience method for not having to call the methods explained in section Section “ How do I register a listener for a certain type event ” more than once. It works via: <span class="anchor" id="line-145"></span><span class="anchor" id="line-146"></span><p class="line867"><span class="anchor" id="line-147"></span><pre>addModelEventListener(PropertyChangeListener listener, Object modelelement,
<span class="anchor" id="line-148"></span>    String[] eventNames)
<span class="anchor" id="line-149"></span></pre><span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line874">You can pass the method an array of strings with event names in which your listener is interested. <span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><p class="line874">Thirdly there is a very powerful method to register your listener to ALL events fired by a ALL model elements of a certain class. You can understand that using this method can have severe performance impacts. Therefore use it with care. The method is: <span class="anchor" id="line-154"></span><span class="anchor" id="line-155"></span><p class="line867"><span class="anchor" id="line-156"></span><pre>addClassModelEventListener(PropertyChangeListener listener, Object modelClass)
<span class="anchor" id="line-157"></span></pre><span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><p class="line874">There are also methods that allow you to register only for one type of event fired by all model elements of a certain class and to register for a set of types of events fired by all mod elements of a certain class. <span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><p class="line874">Of course you can remove your listeners from the event pump. This works with methods starting with remove instead of add. <span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><p class="line867">
<h4 id="head-0110cde81efac2c402589744475d0e40164c9eca">Tips</h4>
<span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><ol type="1"><li>Don't forget to remove your listener from the event pump if it's not interested in some event any more. <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span></li><li class="gap" style="list-style-type:none">If you do not remove it, that's gonna cost performance and it will give you a hard time to debug all the logical bugs you see in your listener. <span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span></li><li class="gap">When you implement your listener, it is wise to NOT DO the following: <span class="anchor" id="line-170"></span></li><li style="list-style-type:none"><span class="anchor" id="line-171"></span><pre>      propertyChanged(MElementEvent event) {
<span class="anchor" id="line-172"></span>            // do my thing for event type 1
<span class="anchor" id="line-173"></span>            // do my thing for event type 2
<span class="anchor" id="line-174"></span>            // etc.
<span class="anchor" id="line-175"></span>      }
<span class="anchor" id="line-176"></span></pre><span class="anchor" id="line-177"></span><span class="anchor" id="line-178"></span></li><li class="gap" style="list-style-type:none">This will cause the things that need to be done for event type 1 to be fired when event type 2 happens. <span class="anchor" id="line-179"></span><span class="anchor" id="line-180"></span></li><li class="gap" style="list-style-type:none"><p class="line862">This still happens in a lot of places in the code of ArgoUML, most notably in the <tt>modelChanged</tt> method of the children of <tt>FigEdgeModelElement</tt>. <span class="anchor" id="line-181"></span><span class="anchor" id="line-182"></span></li></ol><p class="line867">
<h4 id="head-5ec078231f79b798e7e8f8cb7f1cf9359a2fa3a7">Possible investigation points and improvements</h4>
<span class="anchor" id="line-183"></span><span class="anchor" id="line-184"></span><p class="line874">Should we use our own event types? <span class="anchor" id="line-185"></span><span class="anchor" id="line-186"></span><p class="line862">Should we replace the <tt>MElementListener</tt> with <tt>PropertyChangeListener</tt> and <tt>MElementEvent</tt> with <tt>PropertyChangeEvent</tt>? One reason we have not done so yet is that it involves a lot of work and testing. <span class="anchor" id="line-187"></span><span class="anchor" id="line-188"></span><p class="line874">Should we change the implementation of the Event pump itself? Not the API but the implementation! <span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><p class="line874">At the moment the event pump does not use the AWT Event Thread for dispatching events. This can make ArgoUML slow (in the perception of the user). <span class="anchor" id="line-191"></span><span class="anchor" id="line-192"></span><p class="line862">Use the standard data structure that Swing uses for event registration (i.e. <tt>javax.swing.EventListenerList</tt>). Would this be an improvement? <span class="anchor" id="line-193"></span><span class="anchor" id="line-194"></span><p class="line867">
<h3 id="head-f5383edddfbe203300f34a3bc1ab626195ab9bd8">NSUML specifics</h3>
<span class="anchor" id="line-195"></span><span class="anchor" id="line-196"></span><p class="line862">Up to version 0.18.1, ArgoUML used the NSUML model repository internally to implement the UML model. Since version 0.19.1, the NSUML implementation was replaced with the Net<strong></strong>Beans Model Data Repository (MDR) which implements the JSR-040 Java Metadata Interface. <span class="anchor" id="line-197"></span><span class="anchor" id="line-198"></span><p class="line867">
<h3 id="head-ca18705e9cbccb87b487477cf4014155ae19bcc7">The use of IDs in MDR</h3>
<span class="anchor" id="line-199"></span><span class="anchor" id="line-200"></span><p class="line874">All changes to the MDR repository are effectively serialized in the form of change events. The ArgoUML Model-MDR subsystem gets notified before each change with the contents of the change that is about to be made and then again after the change is made. The latter is what we propogate back to the ArgoUML application as model subsystem events. <span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span><p class="line874">UUIDs aren't used internally by MDR. We only maintain UUIDs because PGML requires them. MDR has two types of IDs: 1) MOF ID - managed by the repository and guaranteed unique within it for the life of the repository, and 2) xmi.id - used within a single XMI file to link various items together (type references, etc). What gets called a "UUID" is actually the MOF ID of the creating repository. We maintain an internal mapping that gets created every time a new XMI file gets read to map from this "UUID" to the current internal MOF ID. <span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><p class="line867">
<h3 id="head-7524d534279a42812fa8763e949a6e048f89a4c7">How to work against the model</h3>
<span class="anchor" id="line-205"></span><span class="anchor" id="line-206"></span><p class="line874">The Model subsystem is a set of classes that lay between the model implementation (e.g. MDR) and the rest of ArgoUML that hides the APIs of the implementation. It was originally implemented to provide the ability to switch between NSUML and MDR. This is the API classes of the Model subsystem i.e. Factories, Helpers, Event Pump (where to register for changes). <span class="anchor" id="line-207"></span><span class="anchor" id="line-208"></span><p class="line874">Here follows a list of how different things were done to make the transition easy. Everything within ArgoUML should access the Model subsystem through the interfaces in the org.argouml.model package. The NSUML or MDR and whatever other implementation we eventually come up with would provide the implementation of those interfaces. <span class="anchor" id="line-209"></span><span class="anchor" id="line-210"></span><p class="line874">Table 5.1. How to work against the model <span class="anchor" id="line-211"></span><div><table><tbody><tr>  <td><p class="line862"> What </td>
  <td><p class="line862"> NSUML (use only within Model subsystem)      </td>
  <td><p class="line862"> MDR (use only within Model subsystem)        </td>
  <td><p class="line862"> Model subsystem </td>
</tr>
<tr>  <td><span class="anchor" id="line-212"></span><p class="line862"> Test that an Object o has a certain type     </td>
  <td><p class="line862"> o instanceof Mmodelelementtype → boolean     </td>
  <td><p class="line862"> ???CLASSNAME???​.isInstanceOf(​<a class="nonexistent" href="http://argouml.tigris.org/wiki/RefObject">?</a>RefObject toTest, String className) → boolean         </td>
  <td><p class="line862"> Model.getFacade()​.isAmodelelementtype(o) → boolean </td>
</tr>
<tr>  <td><span class="anchor" id="line-213"></span><p class="line862"> Get a single valued model element from an Object o   </td>
  <td><p class="line862"> ((Mmodelelementtype)o)​.getproperty() → model element        </td>
  <td><p class="line862"> ((<a class="nonexistent" href="http://argouml.tigris.org/wiki/RefFeatured">?</a>RefFeatured)obj)​.refGetValue(​String propName) → ???Type???       </td>
  <td><p class="line862"> Model.getFacade()​.getproperty(o) → Object </td>
</tr>
<tr>  <td><span class="anchor" id="line-214"></span><p class="line862"> Get a multi valued property from an Object o </td>
  <td><p class="line862"> ((Mmodelelementtype)o)​.getproperty() → Collection   </td>
  <td><p class="line862"> ((<a class="nonexistent" href="http://argouml.tigris.org/wiki/RefFeatured">?</a>RefFeatured)obj)​.refGetValue(String propName) → Collection        </td>
  <td><p class="line862"> Model.getFacade()​.getproperty(o) → Iterator or Collection (total confusion!) </td>
</tr>
<tr>  <td><span class="anchor" id="line-215"></span><p class="line862"> Create a new model element of type Type:     </td>
  <td><p class="line862"> MFactory​.getDefaultFactory()​.createType()  </td>
  <td><p class="line862"> ???CLASSNAME???​.creatInstance(​String "Type", List argument) → <a class="nonexistent" href="http://argouml.tigris.org/wiki/RefObject">?</a>RefObject    </td>
  <td><p class="line862"> Model​.getModelElementDomain?Factory​.buildmodelelementtype(args) or Model​.getModelElementDomain?Factory​.createmodelelementtype() to create them completely empty. </td>
</tr>
<tr>  <td><span class="anchor" id="line-216"></span><p class="line862"> Delete a model element       </td>
  <td><p class="line862">      </td>
  <td><p class="line862">      </td>
  <td><p class="line862"> Model​.getUmlFactory()​.delete(​object) ... but only call this function from Project.moveToTrash(Object). </td>
</tr>
<tr>  <td><span class="anchor" id="line-217"></span><p class="line862"> Register for notification that a model element Object o has changed:         </td>
  <td><p class="line862"> ((MBase) o)​.addMElementListener(​MElementListener el)       </td>
  <td><p class="line862"> ((MDRChangeSource) obj)​.addChangeListener(???)      </td>
  <td><p class="line862"> Model.getPump()​.addModelEventListener(​(<a class="nonexistent" href="http://argouml.tigris.org/wiki/PropertyChangeListener">?</a>PropertyChangeListener)li, Object o, String[] eventnames) </td>
</tr>
<tr>  <td><span class="anchor" id="line-218"></span><p class="line862"> Register for notification on all model elements of a certain type Type:      </td>
  <td><p class="line862"> Not possible!        </td>
  <td><p class="line862"> ((MDRChangeSource)obj​.refClass())​.addChangeListener(???)   </td>
  <td><p class="line862"> Model.getPump()​.addModelEventListener(​(<a class="nonexistent" href="http://argouml.tigris.org/wiki/PropertyChangeListener">?</a>PropertyChangeListener)li, (Object)Model​.getMetaTypes()​.getMODELELEMENTTYPE(), String[] eventnames) </td>
</tr>
<tr>  <td><span class="anchor" id="line-219"></span><p class="line862"> How do I get the model as XMI on the stream Stream:  </td>
  <td><p class="line862"> (new XMIWriter(MModel m, Writer Stream)).gen()       </td>
  <td><p class="line862"> new XMIWriter(???)   </td>
  <td><p class="line862"> Handled by the Persistence subsystem. </td>
</tr>
</tbody></table></div><span class="anchor" id="line-220"></span><span class="anchor" id="line-221"></span><p class="line867">
<h3 id="head-78d1c94a15c36dd65b93d863c6f68217a2b4d3a9">How do I...?</h3>
<span class="anchor" id="line-222"></span><span class="anchor" id="line-223"></span><ul><li>...add a new model element? <span class="anchor" id="line-224"></span><span class="anchor" id="line-225"></span></li><li class="gap" style="list-style-type:none"><p class="line862">Make a parameterless build method for your model element in one of the UML Factories (for instance <a class="nonexistent" href="http://argouml.tigris.org/wiki/CoreFactory">?</a>CoreFactory). Use the UML 1.4 spec to choose the correct Factory. The package structure under org.argouml.model follows the chapters in the UML spec so get it and read it! In the build method, create a new model element using the appropriate create method in the factory. The build method e.g. is a wrapper around the create method. For all elements there are already create methods (thanks Thierry). For some elements there are already build methods. If you need one of these elements, use the build method before you barge into building new ones. Initialize all things you need in the build method as far as they don't need other model elements. In the UML spec you can read which elements you need to initialize. See for example buildAttribute() for an example. <span class="anchor" id="line-226"></span><span class="anchor" id="line-227"></span></li><li class="gap" style="list-style-type:none">If you need to attach other already existing model elements to your model element make a buildXXXX(MModelelement toattach1, ...) method in the factory where you made the build method. Don't ever call the create methods directly. If we use the build methods we will always have initialized model elements which will make a difference concerning save/load issues for example. <span class="anchor" id="line-228"></span><span class="anchor" id="line-229"></span></li><li class="gap" style="list-style-type:none">Now you probably also need to create a Property Panel and a Fig object (See Section 5.3.3.5, “Creating a new Fig (explanation 2)”). <span class="anchor" id="line-230"></span><span class="anchor" id="line-231"></span></li><li class="gap">...create a new create method? <span class="anchor" id="line-232"></span><span class="anchor" id="line-233"></span></li><li class="gap" style="list-style-type:none">Create it in the correct factory. <span class="anchor" id="line-234"></span><span class="anchor" id="line-235"></span></li><li class="gap">...create a new utility method? <span class="anchor" id="line-236"></span><span class="anchor" id="line-237"></span></li><li class="gap" style="list-style-type:none">Create it in the correct helper. <span class="anchor" id="line-238"></span><span class="anchor" id="line-239"></span></li><li class="gap">...delete a model element? <span class="anchor" id="line-240"></span><span class="anchor" id="line-241"></span></li><li class="gap" style="list-style-type:none">Project.moveToTrash(Object obj). <span class="anchor" id="line-242"></span><span class="anchor" id="line-243"></span></li><li class="gap" style="list-style-type:none">(See issue 2353.) <span class="anchor" id="line-244"></span><span class="anchor" id="line-245"></span></li></ul><p class="line867">
<h3 id="head-89d331c5a734afaa230077e5eac13d6d2e103840">Code Example</h3>
<span class="anchor" id="line-246"></span><span class="anchor" id="line-247"></span><p class="line862">See the <a href="Code_example_for_model_subsystem_usage.html">Code example for model subsystem usage</a>. <span class="anchor" id="line-248"></span><span class="anchor" id="line-249"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-250"></span><a href="CategoryFromCookbook.html">CategoryFromCookbook</a> <span class="anchor" id="line-251"></span><span class="anchor" id="bottom"></span></div><p id="pageinfo" class="info" lang="en" dir="ltr">&lt;&lt;Subsystem&gt;&gt; Model  (last edited 2010-07-21 17:26:42 -0700 by <span title="Linus Tolke @ localhost[127.0.0.1]"><a href="linus.html" title="Linus Tolke @ localhost[127.0.0.1]">linus</a></span>)</p>

